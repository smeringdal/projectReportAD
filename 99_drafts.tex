\chapter{Drafts}
\section{Shared Libraries vs Static Libraries}
The difference between shared libraries and static libraries is how they handle their dependencies. When static libraries are compiled all the code that is needed for the functions in the library is compiled into the library. This means that all the code that is needed for the library to function properly is "copied" to where it is needed. Shared libraries on the other hand has a reference to its dependencies. This will ad an extra cost to the execution since the code need to look up where the code it is supposed to run lies. The advantage of this compared to Static libraries is that the size of the library becomes smaller as we avoid replicates of code.

\section{Profiling}
Profiling is an effective method to obtain overview of where the bottlenecks lie in a code when trying to optimize its performance. The method consist of taking snapshots of the code with small time intervals and for each snapshot we register what function we are at and the functions that have called this function. In this way we obtain a register of how many times we have observed that we have been in every function. This will not give a perfect overview of how much time we spend in each function, and we even risk not registering all functions we use. But as the time interval between the snapshots are small (e.g. every tenth microsecond), a function that is not registered will not be interesting to optimize as it already is very fast. 

\section{Vectorization vs Non-vectorization}
\emph{\citep{Vectorization}} explains how Julia is faster at executing devectorized code compared to vectorized code.

\emph{\citep{MoreDotsJuliaBlog}}
Ordinary vectorized code is fast, but not as fast as a hand-written loop (assuming loops are efficiently compiled, as in Julia) because each vectorized operation generates a new temporary array and executes a separate loop, leading to a lot of overhead when multiple vectorized operations are combined.