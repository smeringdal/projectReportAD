\chapter{Conclusion and Future Work}
\label{ch:Conclusion}
This thesis has investigated the possibility of using the new programming language, Julia, as a language both for implementing prototypes of new oil reservoir simulators, as well as building efficient industrial simulators. The process of creating an industrial simulator usually consist of first creating a prototype that is further developed to be an industrial simulator. In SINTEF's approach, the prototype and the finished simulator is implemented in two different languages. A high-level scripting language for the prototype and a lower-level, compiled language for the finished simulator. The possibility of performing the whole implementation process in Julia may contribute to increase the efficiency of developing new computational tools significantly.

To investigate this, the thesis has looked further into solving PDEs that describe flow in porous media, using Automatic Differentiation (AD) and a finite-volume method. The PDEs are solved by discretizing the divergence and gradient operators such that the discrete equations can be implemented very similar to the continuous. By setting up the equations as a vector function on residual form, the system can be solved using AD to obtain the Jacobian of the system and the Newton--Raphson method to find the roots of the function. The focus of the thesis has been to look at the performance of the AD tools. Three new AD implementations in Julia have been presented and compared to a third-party implementation in Julia and AD tools from MRST, a reservoir simulation toolbox created in MATLAB by the Computational Geosciences group in the department of Mathematics and Cybernetics at SINTEF Digital\emph{\citep{mrstHomepage}}. 

The AD libraries are benchmarked against each other in a prototype of a single-phase flow solver, simulating primary production from a reservoir with one well producing oil. The third-party implementation of AD, with its dense matrix structure, proved useless for calculating the sparse Jacobians that correspond to the residual function. For this simulation, it is more than 30 times slower than the other AD tools and it is not further considered after this result. The first two implementations in Julia are called \texttt{ForwardAutoDiff}(\texttt{FAD}) and \texttt{CustomJacobianAutoDiff}(\texttt{CJAD}). These are high-level AD tools that are easy to use and that are based on the implementation in MRST. \texttt{CJAD} is an extension of \texttt{FAD}, where \texttt{FAD} only uses sparse matrix structure for its Jacobians, \texttt{CJAD} makes optimized calculations when the Jacobian is a diagonal-, identity-, or null matrix. For the single-phase simulation \texttt{CJAD} and MRST perform similar, while \texttt{FAD} is approximately twice as slow. 

The last AD tool in Julia is called local AD and is implemented as a motivation from the properties of the single-phase simulation. It is similar to how AD is implemented in OPM \emph{\citep{opm}}, which is written in C and C++. Hence, local AD is a lower-level implementation than \texttt{FAD} and \texttt{CJAD}, and since OPM is the tool SINTEF recommends for creating efficient industrial simulators, it is expected that this will give an improved performance. For the single-phase solver, local AD is approximately six times faster than \texttt{CJAD} and MRST. To further test the abilities of local AD, a second simulator is implemented. This is a two-phase solver, simulating the flow of water, in a single layer of the SPE10 reservoir \emph{\citep{SPE10}}, when injecting water into the centre of the reservoir. For this simulation, \texttt{CJAD} and MRST still perform similarly, and the local AD method is approximately five times as fast.

The implementation and benchmarks of \texttt{CJAD} indicate that Julia is well suited for making quick prototypes of simulators, and the benchmarks of local AD give good indications that it could also be possible to create efficient industrial simulators for oil recovery. However, the local AD implementation has only been tested for a grid with less than 15,000 cells and not on a full realistic simulation model. As a reference, the full SPE10 grid has 1,122,000 cells. A natural next step in testing Julia is to make an implementation like local AD in MATLAB and compare the two languages. Since local AD depends on fast execution of for-loops, it is not expected that MATLAB will manage to execute local AD efficient, but it is a good test to see if Julia actually is a step forward compared to MATLAB. As mentioned in \autoref{sec:parallelComputing}, macro functions to parallelize for-loops are under development in Julia. As soon as these functions becomes more stable it will be easy to add it into the functions that assemble the equations in local AD, and it would be interesting to see if this can improve the current implementation. This has been attempted, but the macro functions are at the moment too unstable. A final investigation will be to confirm whether Julia can match the computational efficiency of OPM, or other industrial simulators, in a full-scale realistic simulation. 

